# 類型安全

Swift的類型系統相較C系語言在語法上更為簡潔，但在安全性上有著極大提升。

首先[定義強類型、弱類型、靜態類型、動態類型](https://www.zhihu.com/question/19918532/answer/21647195)。

轮子哥的回答：
强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。
弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。
静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。
动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。

## 簡化

已經介紹過常量變量的聲明。雖然語法有所簡化，但可以看出Swift的變量類型是需要在編譯時確定的，也就是說Swift是一門靜態類型的語言。
在大部分情況下，我們在聲明時會直接對其賦值，因此可以通過類型推斷來省略類型的書寫。而且大家知道，以Apple的命名風格，一個類型的名字通常都挺長的，所以對開發者來說這樣是能省下不少時間的。而且因為類型在編譯時能夠確定，因此也不需要擔心使用`let`、`var`造成語義不清晰。如果你暫時忘了某個變量的類型，善用IDE的提示，Xcode（在不抽風的情況下）在類型確定上是能幫助你很多的。
雖然類型推斷的結果在大多數情況下都是你想要的類型，但有些時候你必須要指定長度或者聲明無符號類型，比如在和Objective-C代碼橋接或做底層指針相關操作的時候，這時候你也可以顯式聲明他的類型。比如`Int8``UInt64`、`Float16`，你熟悉的C中的這些數字類型都能在Swift中找到名字類似的等價類型。你能夠將整型數字賦值給這些類型是因為Swift認為這些類型可用整型字面量表示（`ExpressibleByIntegerLiteral`），之後會介紹，你也可以自己聲明這種可用整型或浮點數、字符串等表示的類型。

## 提升

Swift的類型安全遠不只是利用類型推斷的語法糖。Swift是一門真正的強類型語言。C系語言雖然在編譯時確定類型，但存在大量隱式類型轉換，也就是說C系語言是弱類型的語言。
雖然Swift中`let sum = 42 + 42.0`能夠運行，但以下代碼是會在編譯時報錯的，因為你不能對不同數據類型進行加法運算。前者能夠運行是因為在加法語境下將`42`推斷成了和`42.0`一樣的`Double`類型。

``` Swift
let intNumber = 42
let doubleNumber = 42.0
_ = intNumber + doubleNumber
```

而且運算的溢出在很多情況下會造成一些不確定的錯誤行為。因為Swift對於未定義行為的嚴格控制，因此其做法是在出錯後停止執行。如果你一定要進行溢出運算，那必須在運算符前加一個`&`符號，那樣運行時就會忽略溢出的錯誤。

## 意義

C系語言本身是靜態類型、弱類型的語言，但Objective-C強大的運行時特性使得靜態類型的特點都不復存在。作為成熟的Objective-C開發者，相信各位都有被Objective-C的動態類型、弱類型坑過。
在做數值相關操作的時候，你可能不認為弱類型是個坑，畢竟你對不同類型的數值進行轉換更容易了。但是在處理布爾值的時候就很危險了。雖然Objective-C有`BOOL`類型，C99也新增了`bool`，但你傳其他類型作為條件也不會有問題。传入的类型會被隱式轉換成數值，只有0會被認為是假，而`NULL`、`nil`其实是其他类型的`0`，所以会被认为假。比如你可能需要判斷某個`NSNumber`的值是`0`，但你忘了判斷非空，那就會導致問題。這類問題一旦發生，編譯時運行時都不會有任何報錯，只是邏輯問題，完全需要人工review來避免。
由于Swift是强类型语言，在Swift中空值`nil`，数值`0`，条件假`false`是三种不同类型，不能隐式转换，因此在条件判断上不会出现这类问题。

動態類型引發的問題就更是不勝枚舉了。碰到最多的就是數組或字典，你可以把任何對象放進去。比方說`NSArray<NSString *> *stringArray`，即使我們對它加上了字符串對類型約束，你仍然可以把其他類型的數據放進去而不會報錯，但當把數據取出來以為他是字符串直接使用就崩潰了。
還比如一個網絡請求返回 JSON，其中某一項傳來一個 `null`，結果轉換之後拿到了 `NSNull`，你還把他當成字符串或數字處理，那一樣會崩潰。
Swift的靜態類型將這一切類型判斷前置，你在拿到數據的時候一定是正確的類型，如果有錯誤會在之前發現，你能夠提前進行處理。
